# Fundamentals
[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'vim-denops/denops.vim'
lazy = true

[[plugins]]
repo = 'Shougo/denite.nvim'
depends = ['vim-devicons']
hook_add = '''
  call denite#custom#option("default", {
    \ "split": "floating",
    \ "start_filter": v:true,
    \ "highlight_matched_char": "None",
    \ "highlight_matched_range": "Search",
    \ "match_highlight": v:true,
    \ "smartcase": v:true,
    \ })

  nnoremap \d :<C-u>Denite<Space>
  nnoremap \D :<C-u>Denite<Space>
  nnoremap \f :<C-u>Denite file/rec<CR>
  nnoremap <M-m> :<C-u>Denite file_mru<CR>
  nnoremap <M-o> :<C-u>Denite outline<CR>
  if executable('ag')
    call denite#custom#var('file/rec', 'command', ['ag', '--nocolor', '--nogroup', '--hidden', '--ignore', '.git', '-g',  ''])
    call denite#custom#var('grep', {
    \ 'command': ['ag'],
    \ 'default_opts': ['-i', '--vimgrep'],
    \ 'recursive_opts': [],
    \ 'pattern_opt': [],
    \ 'separator': ['--'],
    \ 'final_opts': [],
    \ })
  endif
  call denite#custom#source('_', 'matchers', ['matcher/regexp', 'matcher/hide_hidden_files'])
  call denite#custom#source('command_history', 'matchers', ['matcher/fuzzy'])
  call denite#custom#source('source', 'matchers', ['matcher/substring'])
  call denite#custom#source('output', 'matchers', ['matcher/fuzzy'])
  autocmd FileType denite call MyDeniteSettings()
  function! MyDeniteSettings() abort
    nnoremap <silent><buffer><expr> <CR> denite#do_map('do_action')
    nnoremap <silent><buffer><expr> s denite#do_map('do_action', 'vsplit')
    nnoremap <silent><buffer><expr> S denite#do_map('do_action', 'split')
    nnoremap <silent><buffer><expr> t denite#do_map('do_action', 'tabopen')
    nnoremap <silent><buffer><expr> d denite#do_map('do_action', 'delete')
    nnoremap <silent><buffer><expr> p denite#do_map('do_action', 'preview')
    nnoremap <silent><buffer><expr> q denite#do_map('quit')
    nnoremap <silent><buffer><expr> i denite#do_map('open_filter_buffer')
    nnoremap <silent><buffer><expr> <Space> denite#do_map('toggle_select').'j'
    nmap <silent><buffer><expr> <Esc> denite#do_map('quit')
  endfunction

  autocmd FileType denite-filter call MyDeniteFilterSettings()
  function! MyDeniteFilterSettings() abort
    imap <silent><buffer> <Esc> <Plug>(denite_filter_update)
    inoremap <silent><buffer><expr> <C-l> denite#do_map('redraw')
    inoremap <silent><buffer><expr> <CR> denite#do_map('do_action')
  endfunction
'''

[[plugins]]
repo = 'neovim/nvim-lspconfig'
hook_add = '''
  luafile ~/.config/nvim/lsp.lua
'''

[[plugins]]
repo = 'Shougo/neomru.vim'
depends = 'denite.nvim'
hook_add = '''
  let g:neomru#file_mru_limit = 10000
'''

# Filetypes
[[plugins]]
repo = 'cespare/vim-toml'


# Insersion
[[plugins]]
repo = 'Shougo/ddc.vim'
depends = [
  'denops.vim',
  'neosnippet',
  'ddc-matcher_head',
  'ddc-sorter_rank',
  'ddc-file',
  'ddc-fuzzy',
  'ddc-nvim-lsp',
  'ddc-buffer',
  'ddc-ctags',
  'pum.vim',
  'denops-popup-preview.vim',
]
on_event = ['InsertEnter', 'CmdlineEnter']
hook_source = '''
  call ddc#custom#patch_global({
    \ 'sources': ['nvim-lsp', 'neosnippet', 'ctags', 'buffer', 'file'],
    \ 'completionMenu': 'pum.vim',
    \ 'backspaceCompletion': v:true,
    \ 'sourceOptions': {
    \   '_': {
    \     'matchers': ['matcher_fuzzy'],
    \     'sorters': ['sorter_fuzzy'],
    \     'converters': ['converter_fuzzy'],
    \     'minAutoCompleteLength': 1,
    \   },
    \   'buffer': {'mark': 'Buff'},
    \   'ctags': {'mark': 'Tag'},
    \   'neosnippet': {'mark': 'Snip'},
    \   'file': {
    \     'mark': 'File',
    \     'isVolatile': v:true,
    \     'forceCompletionPattern': '\S/\S*',
    \   },
    \   'nvim-lsp': {
    \     'mark': 'LSP',
    \     'forceCompletionPattern': '\.\w*|:\w*',
    \   },
    \ },
    \ 'sourceParams': {
    \   'buffer': {
    \     'requireSameFiletype': v:false,
    \     'limitBytes': 5000000,
    \     'fromAltBuf': v:true,
    \     'forceCollect': v:true,
    \   },
    \   'ctags': {'executable': '/usr/bin/ctags'},
    \ },
    \ 'filterParams': {
    \   'matcher_fuzzy': {'splitMode': 'word'},
    \ },
    \ })
  call ddc#custom#patch_filetype(['python'], 'sourceOptions', {
    \  'nvim-lsp': {
    \   'forceCompletionPattern': '\.\w*|:\s\w*|import\s\w*|@\w*',
    \ },
    \ })
  call ddc#enable()
'''

[[plugins]]
repo = 'matsui54/ddc-buffer'
lazy = 1

[[plugins]]
repo = 'Shougo/ddc-matcher_head'
lazy = 1

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
lazy = 1

[[plugins]]
repo = 'LumaKernel/ddc-file'
lazy = 1

[[plugins]]
repo = 'tani/ddc-fuzzy'
lazy = 1

[[plugins]]
repo = 'Shougo/ddc-nvim-lsp'
lazy = 1

[[plugins]]
repo = 'delphinus/ddc-ctags'

[[plugins]]
repo = 'Shougo/pum.vim'
lazy = 1
hook_source = '''
  inoremap <C-n> <Cmd>call pum#map#insert_relative(+1)<CR>
  inoremap <C-p> <Cmd>call pum#map#insert_relative(-1)<CR>
  inoremap <C-y> <Cmd>call pum#map#confirm()<CR>

  call pum#set_option({
    \ 'border': 'single',
    \ })
'''

[[plugins]]
repo = 'matsui54/denops-popup-preview.vim'
lazy = 1
hook_source = '''
  call popup_preview#enable()
'''

[[plugins]]
repo = 'Shougo/neosnippet'
depends = 'neosnippet-snippets'
filetypes = 'neosnippet'
on_event = 'InsertEnter'
hook_source = '''
  let g:neosnippet#snippets_directory = expand('~/.config/nvim/snippets')
  imap <C-k> <Plug>(neosnippet_expand_or_jump)
  smap <C-k> <Plug>(neosnippet_expand_or_jump)
  xmap <C-l> <Plug>(neosnippet_expand_target)
  snoremap <C-l> <Esc>a
  snoremap <CR> <BS>i
'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = ['InsertEnter', 'CmdlineEnter']
hook_source = '''
  " lexima settings {{{
  let g:lexima_no_default_rules = 1
  let g:lexima_map_escape = ''
  let g:lexima_accept_pum_with_enter = 0
  inoremap <silent> <Esc> <C-r>=lexima#insmode#escape()<CR><C-r>=FixedInsertLeave()<CR>:call ImActivateFunc(0)<CR>
  call lexima#set_default_rules()

  call lexima#add_rule({'at': '^```\(\S*\)\%#```', 'char': '<CR>', 'input': '<CR>', 'input_after': '<CR>'})
  call lexima#add_rule({'at': '^\k\+\s*::\s*.*\%#', 'char': '<CR>', 'input': '<Esc>^"qyt<Space>o<C-r>q<Space>', 'filetype': ['haskell']})
  call lexima#add_rule({'at': '{-\%#}', 'char': '#', 'input': '# ', 'input_after': ' #-', 'filetype': ['haskell']})
  call lexima#add_rule({'at': '{\%#}', 'char': '<CR>', 'input': '<CR><Bslash> ', 'input_after': '<CR><Bslash> ', 'filetype': 'vim'})
  call lexima#add_rule({'at': '\\\s.*\%#$', 'char': '<CR>', 'input': '<CR><Bslash> ', 'filetype': 'vim'})

  call lexima#add_rule({'at': '^\%#', 'char': '/', 'input': '<BS>:Denite line<CR>', 'mode': '/'})
  call lexima#add_rule({'at': '^\%#', 'char': '?', 'input': '<BS>:Denite line<CR>', 'mode': '?'})
  call lexima#add_rule({'at': '^\%#', 'char': ':', 'input': '<BS>:Denite command_history<CR>', 'mode': ':'})

  call lexima#add_rule({'at': 'RenameMe\%#', 'char': '<Space>', 'input': '<Space><C-r>%', 'mode': ':'})
  call lexima#add_rule({'at': 'Git commit --amend \%#', 'char': 'c', 'input': '-C HEAD', 'mode': ':'})
  call lexima#add_rule({'at': 'Git commit --amend \%#', 'char': 'C', 'input': '-C HEAD', 'mode': ':'})
  call lexima#add_rule({'at': 'Git ca\%#', 'char': 'm', 'input': '<C-u>Gcommit --amend ', 'mode': ':'})

  call lexima#add_rule({'at': 'Denite \%#', 'char': 'O', 'input': 'outline', 'mode': ':'})
  call lexima#add_rule({'at': 'Denite \%#', 'char': 'F', 'input': 'file', 'mode': ':'})
  call lexima#add_rule({'at': 'Denite \%#', 'char': 'B', 'input': 'buffer', 'mode': ':'})
  call lexima#add_rule({'at': 'Denite \%#', 'char': 'C', 'input': 'change', 'mode': ':'})
  call lexima#add_rule({'at': 'Denite \%#', 'char': 'J', 'input': 'jump', 'mode': ':'})

  call lexima#add_rule({'at': '^\s*\%(Describe\|Context\|It\|Before\|After\)\s\+.*\%#', 'char': '<CR>', 'input_after': '<CR>End', 'filetype': 'vimspec'})
  " }}}
'''

# TextObj
[[plugins]]
repo = 'kana/vim-textobj-user'

[[plugins]]
repo = 'kana/vim-textobj-indent'
depends = 'vim-textobj-user'

[[plugins]]
repo = 'kana/vim-textobj-entire'
depends = 'vim-textobj-user'
on_map = {ox = ['ie', 'ae']}

[[plugins]]
repo = 'thinca/vim-textobj-between'
depends = 'vim-textobj-user'
on_map = {ox = '<Plug>'}
hook_add = '''
  let g:textobj_between_no_default_key_mappings = 1
  omap i/ <Plug>(textobj-between-i)
  xmap i/ <Plug>(textobj-between-i)
  omap a/ <Plug>(textobj-between-a)
  xmap a/ <Plug>(textobj-between-a)
'''

[[plugins]]
repo = 'kana/vim-textobj-line'
depends = 'vim-textobj-user'
on_map = {ox = ['il', 'al']}

[[plugins]]
repo = 'gilligan/textobj-lastpaste'
depends = 'vim-textobj-user'
hook_add = '''
  let g:textobj_lastpaste_no_default_key_mappings = 1
  omap iP <Plug>(textobj-lastpaste-i)
  xmap iP <Plug>(textobj-lastpaste-i)
'''

[[plugins]]
repo = 'thinca/vim-textobj-comment'
depends = 'vim-textobj-user'
on_map = {ox = ['ic', 'ac']}

# Operator
[[plugins]]
repo = 'tpope/vim-surround'
on_map = {n = ['ys', 'ds', 'cs'], x = 'S'}

[[plugins]]
repo = 'tpope/vim-commentary'
on_map = {nx = ['gc', 'gC']}

[[plugins]]
repo = 'kana/vim-operator-user'

[[plugins]]
repo = 'kana/vim-operator-replace'
depends = 'vim-operator-user'
on_map = {nox = '<Plug>'}
hook_add = '''
  map _ <Plug>(operator-replace)
  sunmap _
'''

[[plugins]]
repo = 'tyru/operator-camelize.vim'
depends = 'kana/vim-operator-user'
on_map = {nox = '<Plug>'}
hook_add = '''
  map - <Plug>(operator-camelize-toggle)
  sunmap -
'''

[[plugins]]
repo = 'tommcdo/vim-exchange'
on_map = {nox = ['<Plug>(Exchange)', '<Plug>(ExchangeLine)', '<Plug>(ExchangeClear)']}
on_cmd = 'XchangeClear'
hook_add = '''
  let g:exchange_no_mappings = 1
  nmap cx <Plug>(Exchange)
  nmap cxx <Plug>(ExchangeLine)
  xmap X <Plug>(Exchange)
  autocmd myautocmd TextChanged * XchangeClear
'''

# Editing
[[plugins]]
repo = 'h1mesuke/vim-alignta'
on_cmd = ['Alignta', 'Align']

[[plugins]]
repo = 'kana/vim-repeat'

[[plugins]]
repo = 'thinca/vim-template'
hook_add = '''
  autocmd User plugin-template-loaded call MyTemplateLoaded()

  function! MyTemplateLoaded()
    if search('<CURSOR>')
      execute 'normal! "_da>'
    endif
  endfunction
'''


[[plugins]]
repo = 'thinca/vim-qfreplace'
on_cmd = 'Qfreplace'
hook_add = '''
  function! QfreplaceSettings() abort
    nnoremap <buffer> r :<C-u>Qfreplace<CR>
  endfunction
  autocmd myautocmd FileType qf call QfreplaceSettings()
'''

# File
[[plugins]]
repo = 'scrooloose/nerdtree'
on_cmd = ['NERDTreeToggle', 'NERDTreeToggle']
hook_add = '''
  nnoremap <silent> <C-p> :<C-u>NERDTreeToggle<CR>
  nnoremap <silent> <C-@> :<C-u>NERDTreeFind<CR>
  nnoremap <silent> <Leader><C-p> :<C-u>NERDTreeFind<CR>
  let g:NERDTreeIgnore = ['\~$', '\.swp', '^\.$', '^\.\.$']
  let g:NERDTreeHijackNetrw = 0
  let g:NERDTreeQuitOnOpen = 1
  let g:NERDTreeWinSize = 36
  let g:NERDTreeMinimalUI = 1
  let g:NERDTreeChDirMode = 1
  let g:NERDTreeMapCWD = "cD"
  if !g:is_unicode
    let g:NERDTreeDirArrows = 0
  endif
'''

[[plugins]]
repo = 'lambdalisue/suda.vim'
hook_add = '''
  command! SudoWrite w suda://%
'''


# Motion
[[plugins]]
repo = 'bkad/CamelCaseMotion'
hook_add = '''
  map + [CamelCaseMotion]
  map <silent> [CamelCaseMotion]w <Plug>CamelCaseMotion_w
  map <silent> [CamelCaseMotion]b <Plug>CamelCaseMotion_b
  map <silent> [CamelCaseMotion]e <Plug>CamelCaseMotion_e
  sunmap +
  sunmap [CamelCaseMotion]w
  sunmap [CamelCaseMotion]b
  sunmap [CamelCaseMotion]e
'''

[[plugins]]
repo = 'Lokaltog/vim-easymotion'
on_map = {nox = '<CR>'}
hook_source = '''
nmap <CR> [EasyMotion]
omap <CR> [EasyMotion]
xmap <CR> [EasyMotion]
let g:EasyMotion_leader_key = '[EasyMotion]'
'''

[[plugins]]
repo = 'kana/vim-smartword'
on_map = '<Plug>'
hook_add = '''
nmap w <Plug>(smartword-w)
nmap b <Plug>(smartword-b)
nmap e <Plug>(smartword-e)
nmap ge <Plug>(smartword-ge)
xmap w <Plug>(smartword-w)
xmap b <Plug>(smartword-b)
xmap e <Plug>(smartword-e)
xmap ge <Plug>(smartword-ge)
'''

[[plugins]]
repo = 'deton/jasentence.vim'
on_map = {nox = ['(', ')'], ox = ['as', 'is']}

[[plugins]]
repo = 'thinca/vim-visualstar'
on_map = '<Plug>'
hook_add = '''
  let g:visualstar_no_default_key_mappings = 1
  xmap * <Plug>(visualstar-*)
  xmap # <Plug>(visualstar-#)
  xmap g* <Plug>(visualstar-g*)
  xmap g# <Plug>(visualstar-g#)
'''

[[plugins]]
repo = 'deris/columnjump'
on_map = '<Plug>'
hook_add = '''
  let g:columnjump_ignore_wrapped_lines = 1
  nmap <C-k> <Plug>(columnjump-backward)
  xmap <C-k> <Plug>(columnjump-backward)
  nmap <C-j> <Plug>(columnjump-forward)
  xmap <C-j> <Plug>(columnjump-forward)
'''

[[plugins]]
repo = 'kana/vim-gf-user'
lazy = 1

[[plugins]]
repo = 'sgur/vim-gf-autoload'
depends = 'vim-gf-user'
on_ft = 'vim'

# Appearance
[[plugins]]
repo = 'nathanaelkane/vim-indent-guides'
hook_add = '''
  let g:indent_guides_enable_on_vim_startup = 1
  let g:indent_guides_auto_colors = 0
'''

[[plugins]]
repo = 'thinca/vim-fontzoom'
on_if = 'g:is_gui'
on_map = {n = '<Plug>'}
hook_add = '''
  let g:fontzoom_no_default_key_mappings = 1
  nmap <C-ScrollWheelUp>   <Plug>(fontzoom-larger)
  nmap <C-ScrollWheelDown> <Plug>(fontzoom-smaller)
'''

[[plugins]]
repo = 'cohama/vim-insert-linenr'
on_event = 'InsertEnter'

[[plugins]]
repo = 'ryanoasis/vim-devicons'

# Git
[[plugins]]
repo = 'tpope/vim-fugitive'
hook_add = '''
  nnoremap [Git] <Nop>
  nmap <Space> [Git]
  nnoremap [Git]<Space> :<C-u>Git<Space>
  nnoremap [Git]s :<C-u>Git<CR>
  nnoremap [Git]d :<C-u>Gvdiffsplit<CR>
  nnoremap [Git]a :<C-u>Gwrite<CR>
  nnoremap [Git]A :<C-u>Git add -A<CR>
  nnoremap [Git]c :<C-u>Git commit -v<CR>
  nnoremap [Git]C :<C-u>Git commit --amend<Space>
  nnoremap [Git]p :<C-u>Git push<CR>
  nnoremap [Git]f :<C-u>Git fetch<CR>
  nnoremap [Git]F :<C-u>Git pull --rebase<CR>
  nnoremap [Git]b :<C-u>Git blame<CR>

  autocmd myautocmd FileType fugitive call MyFugitiveSettings()
  function MyFugitiveSettings() abort
    nmap <buffer> D dd
    nnoremap <buffer> q :<C-u>q<CR>
  endfunction
'''

[[plugins]]
repo = 'cohama/agit.vim'
on_cmd = ['Agit', 'AgitFile']
hook_add = '''
  autocmd myautocmd FileType agit call s:my_agit_settings()
  function! s:my_agit_settings()
    nmap <buffer> Rv <Plug>(agit-git-revert)
    nmap <buffer> cB :<C-u>AgitGit branch -f \%# <hash><CR>
    nnoremap <buffer> [Git]<Space> :<C-u>AgitGit<Space>
  endfunction
  nnoremap [Git]k :<C-u>Agit<CR>
  nnoremap [Git]K :<C-u>AgitFile<CR>
'''

[[plugins]]
repo = 'airblade/vim-gitgutter'
on_cmd = ['GitGutterToggle', 'GitGutterNextHunk', 'GitGutterNextHunk']
hook_add = '''
  let g:gitgutter_enabled = 0
  nmap <silent> ]h :<C-u>execute v:count1 . "GitGutterNextHunk"<CR>
  nmap <silent> [h :<C-u>execute v:count1 . "GitGutterPrevHunk"<CR>
  nnoremap [Git]g :<C-u>GitGutterToggle<CR>
'''

# Language Support
[[plugins]]
repo = 'itchyny/vim-haskell-indent'
on_ft = 'haskell'

[[plugins]]
repo = 'eagletmt/ghcmod-vim'
on_if = 'executable("ghc-mod")'
on_ft = 'haskell'

[[plugins]]
repo = 'eagletmt/neco-ghc'
on_if = 'executable("ghc-mod")'
on_ft = 'haskell'
hook_add = '''
  let g:necoghc_enable_detailed_browse = 1
'''

[[plugins]]
repo = 'racer-rust/vim-racer'
on_ft = 'rust'
hook_add = '''
  let g:racer_experimental_completer = 1
'''

[[plugins]]
repo = 'Vimjas/vim-python-pep8-indent'
on_ft = 'python'

# Execution
[[plugins]]
repo = 'thinca/vim-quickrun'
on_map = {n = '\r'}
on_cmd = 'QuickRun'
depends = 'quickrun-job-runner.nvim'
hook_add = '''
  autocmd myautocmd BufWinEnter,BufNewFile test/*.vim,test/*.vimspec let b:quickrun_config = {'type' : 'themis'}
  autocmd myautocmd BufWinEnter QuickRunOut setlocal winfixheight
  autocmd myautocmd BufWinLeave QuickRunOut call quickrun#sweep_sessions()
  command! QuickRunCancel call quickrun#sweep_sessions()
'''
hook_source = '''
  " quickrun settings {{{
  let g:quickrun_config = {}
  let g:quickrun_config['_'] = {
  \ 'hook/close_buffer/enable_failure'   : 1,
  \ 'hook/close_buffer/enable_empty_data': 1,
  \ 'outputter'                          : 'multi:buffer:quickfix',
  \ 'outputter/buffer/split'             : 'botright 8',
  \ 'outputter/buffer/name'              : 'QuickRunOut',
  \ 'outputter/buffer/close_on_empty'    : 1,
  \ 'outputter/quickfix/open_cmd'        : '',
  \ 'runner'                             : 'nvim_job',
  \ 'hook/echo/enable'                   : 1,
  \ 'hook/echo/output_success'           : 'success',
  \ 'hook/echo/output_failure'           : 'failure',
  \ }
  let g:quickrun_config['watchdogs_checker/_'] = {
  \ 'hook/close_unite_quickfix/enable_exit'    : 1,
  \ 'hook/back_window/enable_exit'             : 0,
  \ 'hook/quickfix_status_enable/enable_exit'  : 1,
  \ 'outputter/quickfix/open_cmd'              : '',
  \ 'hook/hier_update/enable_exit'             : 1,
  \ 'hook/back_window/priority_exit'           : 1,
  \ 'hook/quickfix_status_enable/priority_exit': 2,
  \ 'hook/hier_update/priority_exit'           : 3,
  \ 'hook/nuko/enable'  : 1,
  \ }
  let g:quickrun_config['ocaml/watchdogs_checker'] = {
  \ 'type': 'watchdogs_checker/ocamlc'
  \ }
  let g:quickrun_config['watchdogs_checker/make'] = {
  \ 'command': 'make',
  \ 'exec': '%c %o'
  \ }
  let g:quickrun_config['watchdogs_checker/ocamlc'] = {
  \ 'command': 'ocamlc',
  \ 'exec'   : '%c -i %o - %s:p'
  \ }
  let g:quickrun_config['watchdogs_checker/ocamlc_annot'] = {
  \ 'command': 'ocamlc',
  \ 'exec'   : '%c -annot -bin-annot -c %o - %s:p'
  \ }
  let g:quickrun_config['watchdogs_checker/hxml'] = {
  \ 'command': 'haxe',
  \ 'exec'   : '%c build.hxml'
  \ }
  let g:quickrun_config['haxe/watchdogs_checker'] = {
  \ 'type': 'watchdogs_checker/hxml'
  \ }
  let g:quickrun_config['ruby.rspec'] = {
  \ 'command': 'bundle',
  \ 'exec': '%c exec rspec -f d %s'
  \ }
  let g:quickrun_config['ghc_make'] = {
  \ 'command'                       : 'ghc',
  \ 'exec'                          : '%c %s',
  \ 'outputter'                     : 'quickfix',
  \ 'outputter/quickfix'            : 1,
  \ 'outputter/quickfix/open_cmd'   : 'cwindow',
  \ 'hook/back_window/enable_exit'  : 1,
  \ 'hook/back_window/priority_exit': 1
  \ }
  let g:quickrun_config['ghc_doctest'] = {
  \ 'command': 'doctest',
  \ 'exec': '%c %s'
  \ }
  let g:quickrun_config['stack_build'] = {
  \ 'command'                       : 'stack',
  \ 'exec'                          : '%c build',
  \ 'outputter'                     : 'quickfix',
  \ 'outputter/quickfix'            : 1,
  \ 'outputter/quickfix/open_cmd'   : 'botright cwindow',
  \ 'hook/back_window/enable_exit'  : 1,
  \ 'hook/back_window/priority_exit': 1,
  \ 'hook/nuko/enable'              : 1,
  \ }
  let g:quickrun_config['stack_exec'] = {
  \ 'command'                       : 'stack',
  \ 'exec'                          : '%c exec %a',
  \ 'outputter'                     : 'buffer',
  \ }
  let g:quickrun_config['haskell'] = {'type': 'haskell/stack_runghc'}
  let g:quickrun_config['haskell/stack_runghc'] = {
  \ 'command'           : 'stack',
  \ 'exec'              : '%c runghc %s %a',
  \ 'tempfile'          : '%{tempname()}.hs',
  \ 'hook/eval/template': 'main = print \$ %s',
  \ }
  let g:quickrun_config['haskell/watchdogs_checker'] = {'type': 'watchdogs_checker/stack_ghcmod'}
  let g:quickrun_config['watchdogs_checker/stack_ghcmod'] = {
  \ 'command'           : 'stack',
  \ 'exec'              : '%c exec ghc-mod check %s:p | sed "s/\x0/\n/g"',
  \ 'errorformat'       : '%f:%l:%c:%trror: %m,%f:%l:%c:%tarning: %m,%f:%l:%c:parse %trror %m,%f:%l:%c: %trror: %m,%f:%l:%c: %tarning: %m,%f:%l:%c:%m,%E%f:%l:%c:,%Z%m',
  \ 'tempfile'          : 'TemporaryWatchDogSourceFile.hs'
  \ }
  let g:quickrun_config['rust/watchdogs_checker'] = {'type': 'watchdogs_checker/myrustc'}
  let g:quickrun_config['watchdogs_checker/myrustc'] = {
  \ 'command'           : 'rustc',
  \ 'exec'              : '%c -Z no-trans %s:p',
  \ }
  let g:quickrun_config['watchdogs_checker/cargo_check'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c check',
  \ }
  let g:quickrun_config['cargo_run'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c run',
  \ }
  let g:quickrun_config['cargo_build'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c build',
  \ }
  let g:quickrun_config['cargo_test'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c test',
  \ 'outputter/buffer/split'             : 'botright vertical 80',
  \ }
  let g:quickrun_config['watchdogs_checker/cargo_clippy'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c clippy',
  \ }
  let g:quickrun_config['themis'] = {
  \ 'command': 'themis',
  \ 'exec': '%c --reporter dot %s'
  \ }
  " }}}
'''

[[plugins]]
repo = 'tamy0612/quickrun-job-runner.nvim'
lazy = 1

[[plugins]]
repo = 'kana/vim-submode'
on_map = {n = ['<C-W>+', '<C-W>-', '<C-W>>', '<C-W><']}
hook_add = '''
  let g:submode_keep_leaving_key = 1
  let g:submode_timeout = 0
'''
hook_source = '''
  call submode#enter_with('winsize', 'n', '', '<C-W>>', '<C-W>>')
  call submode#enter_with('winsize', 'n', '', '<C-W><', '<C-W><')
  call submode#enter_with('winsize', 'n', '', '<C-W>+', '<C-W>+')
  call submode#enter_with('winsize', 'n', '', '<C-W>-', '<C-W>-')
  call submode#map('winsize', 'n', '', '>', '<C-W>>')
  call submode#map('winsize', 'n', '', '<', '<C-W><')
  call submode#map('winsize', 'n', '', '+', '<C-W>+')
  call submode#map('winsize', 'n', '', '-', '<C-W>-')
'''

[[plugins]]
repo = 'tyru/open-browser.vim'
on_map = '<Plug>(openbrowser-'
hook_add = '''
  let g:netrw_nogx = 1
  nmap gx <Plug>(openbrowser-smart-search)
  xmap gx <Plug>(openbrowser-smart-search)
'''

[[plugins]]
repo = 'thinca/vim-themis'

[[plugins]]
repo = 'previm/previm'
on_cmd = 'PrevimOpen'
depends = ['open-browser.vim']

# Miscellaneous
[[plugins]]
repo = 'mattn/webapi-vim'
lazy = 1

[[plugins]]
repo = 'mattn/gist-vim'
depends = 'webapi-vim'
on_cmd = 'Gist'

[[plugins]]
repo = 'thinca/vim-localrc'

[[plugins]]
repo = 'thinca/vim-prettyprint'
on_cmd = ['PP', 'PrettyPrint']

[[plugins]]
repo = 'subnut/nvim-ghost.nvim'
hook_post_update = '''
  call nvim_ghost#installer#install()
'''
hook_add = '''
  autocmd myautocmd User *github.com set filetype=markdown
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
hook_post_update = '''
  TSUpdate
'''
on_event = 'VimEnter'
hook_source = '''
lua <<EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = "maintained",
  ignore_install = {},
  highlight = {
    enable = false,
    disable = {},
    additional_vim_regex_highlighting = false
  },
  indent = {
    enable = false
  }
}
EOF

set foldexpr=nvim_treesitter#foldexpr()
'''
