# Fundamentals
[[plugins]]
repo = 'Shougo/dein.vim'
hook_add = '''
  let g:dein#install_progress_type = 'floating'
  autocmd myautocmd BufWinEnter *dein.toml call dein#toml#syntax()
'''

[[plugins]]
repo = 'vim-denops/denops.vim'

[[plugins]]
repo = 'Shougo/ddu.vim'
depends = [
  'denops.vim',
]
hook_add = '''
  let ignored_dirs = readfile(fnamemodify($MYVIMRC, ':p:h') . '/ddu-source-file_rec-ignored_dirs.txt')
  call ddu#custom#patch_global({
  \   'ui': 'ff',
  \   'sourceOptions': {
  \     '_': {
  \       'matchers': ['matcher_substring'],
  \     },
  \   },
  \   'filterParams': {
  \     'matcher_substring': {'highlightMatched': 'Search'}
  \   },
  \   'uiParams': {
  \     'ff': {
  \       'split': 'floating',
  \       'startFilter': 'v:true',
  \       'floatingBorder': 'single',
  \       'filterFloatingPosition': 'top',
  \     },
  \   },
  \   'sourceParams': {
  \     'file_external': {'cmd': ['fd', '.', '-H', '-E', '.git', '-tf']},
  \     'file_rec': {'ignoredDirectories': ignored_dirs},
  \     'rg': {'args': ['--column', '--no-heading', '--color', 'never']},
  \   },
  \   'kindOptions:': {
  \     'file': {
  \       'defaultAction': 'open',
  \     },
  \   },
  \ })
  command! DduRgLive call <SID>ddu_rg_live()
  function! s:ddu_rg_live() abort
    call ddu#start({
    \   'volatile': v:true,
    \   'sources': [{
    \     'name': 'rg',
    \     'options': {'matchers': []},
    \   }],
    \   'uiParams': {'ff': {
    \     'ignoreEmpty': v:false,
    \     'autoResize': v:false,
    \   }},
    \ })
  endfunction
  nnoremap \F <Cmd>Ddu file_rec<CR>
  nnoremap \f <Cmd>Ddu file_external<CR>
  nnoremap <M-m> <Cmd>Ddu mr<CR>
  nnoremap <M-M> <Cmd>call ddu#start({
  \ "name": "mr",
  \ "sources": [
  \   {
  \     "name": "mr",
  \     "params": {"kind": "mrr"}
  \   }
  \ ]
  \ })<CR>
  nnoremap \ur <Cmd>Ddu -resume<CR>
  nnoremap \ug <Cmd>DduRgLive<CR>

  function! DduFileExternal(dir) abort
    call ddu#start({"name": "file_ext_custom", "sources": [{"name": "file_external"}]})
  endfunction

  command! -nargs=1 -complete=dir DduFileExternal Ddu file_external -source-param-path=<args>
  autocmd FileType ddu-ff call s:ddu_my_settings()
  function! s:ddu_my_settings() abort
    nnoremap <buffer><silent> <CR> <Cmd>call ddu#ui#ff#do_action('itemAction', {'name': 'open'})<CR>
    nnoremap <buffer><silent> s <Cmd>call ddu#ui#ff#do_action('itemAction', {'name': 'open', 'params': {'command': 'vsplit'}})<CR>
    nnoremap <buffer><silent> S <Cmd>call ddu#ui#ff#do_action('itemAction', {'name': 'open', 'params': {'command': 'split'}})<CR>
    nnoremap <buffer><silent> t <Cmd>call ddu#ui#ff#do_action('itemAction', {'name': 'open', 'params': {'command': 'tabedit'}})<CR>
    nnoremap <buffer><silent> C <Cmd>call ddu#ui#ff#do_action('itemAction', {'name': 'open', 'params': {'command': 'tcd'}})<CR>
    nnoremap <buffer><silent> <Space> <Cmd>call ddu#ui#ff#do_action('toggleSelectItem')<CR>
    nnoremap <buffer><silent> i <Cmd>call ddu#ui#ff#do_action('openFilterWindow')<CR>
    nnoremap <buffer><silent> q <Cmd>call ddu#ui#ff#do_action('quit')<CR>
    nnoremap <buffer><silent> <Esc> <Cmd>call ddu#ui#ff#do_action('quit')<CR>

    nnoremap <buffer><silent> F <Cmd>call ddu#ui#ff#do_action('itemAction', {'name': 'open', 'params': {'command': 'DduFileExternal'}})<CR>
  endfunction

  autocmd FileType ddu-ff-filter call s:ddu_filter_my_settings()
  function! s:ddu_filter_my_settings() abort
    inoremap <buffer><silent> <CR> <Esc><Cmd>close<CR><Cmd>call ddu#ui#ff#do_action('itemAction', {'name': 'open'})<CR>
    inoremap <buffer><silent> <Esc> <Esc><Cmd>close<CR>
    nnoremap <buffer><silent> <CR> <Cmd>close<CR>
    inoremap <buffer><silent> <C-l> <Esc><Cmd>call ddu#ui#ff#do_action('refreshItems')<CR>a
  endfunction
'''

[[plugins]]
repo = 'Shougo/ddu-commands.vim'

[[plugins]]
repo = 'Shougo/ddu-ui-ff'

[[plugins]]
repo = 'Shougo/ddu-source-line'

[[plugins]]
repo = 'Shougo/ddu-source-file_rec'

[[plugins]]
repo = 'Shougo/ddu-source-file'

[[plugins]]
repo = 'matsui54/ddu-source-file_external'

[[plugins]]
repo = 'matsui54/ddu-source-command_history'

[[plugins]]
repo = 'kuuote/ddu-source-mr'

[[plugins]]
repo = 'Shougo/ddu-source-rg'

[[plugins]]
repo = 'Shougo/ddu-filter-matcher_substring'

[[plugins]]
repo = 'Shougo/ddu-kind-file'

[[plugins]]
repo = 'lambdalisue/mr.vim'

[[plugins]]
repo = 'neovim/nvim-lspconfig'
on_event = 'VimEnter'
hook_source = '''
  luafile ~/.config/nvim/lsp.lua
'''

# Filetypes
[[plugins]]
repo = 'mechatroner/rainbow_csv'
on_ft = ['csv', 'tsv']
hook_add = '''
  let g:disable_rainbow_key_mappings = 1
  autocmd myautocmd BufReadPost,BufNewFile *.tsv setfiletype tsv
'''

# Insersion
[[plugins]]
repo = 'Shougo/ddc.vim'
depends = [
  'denops.vim',
  'ddc-ui-pum',
  'neosnippet',
  'ddc-matcher_head',
  'ddc-sorter_rank',
  'ddc-around',
  'ddc-file',
  'ddc-fuzzy',
  'ddc-nvim-lsp',
  'ddc-buffer',
  'pum.vim',
  'denops-popup-preview.vim',
  'ddc-converter_remove_overlap',
]
on_event = ['InsertEnter', 'CmdlineEnter']
hook_source = '''
  call ddc#custom#patch_global({
    \ 'ui': 'pum',
    \ 'sources': ['nvim-lsp', 'neosnippet', 'buffer', 'file'],
    \ 'backspaceCompletion': v:true,
    \ 'sourceOptions': {
    \   '_': {
    \     'matchers': ['matcher_fuzzy'],
    \     'sorters': ['sorter_fuzzy'],
    \     'converters': ['converter_fuzzy', 'converter_remove_overlap'],
    \     'minAutoCompleteLength': 1,
    \   },
    \   'buffer': {'mark': 'Buff'},
    \   'neosnippet': {'mark': 'Snip'},
    \   'file': {
    \     'mark': 'File',
    \     'isVolatile': v:true,
    \     'forceCompletionPattern': '\S/\S*',
    \   },
    \   'nvim-lsp': {
    \     'mark': 'LSP',
    \     'forceCompletionPattern': '\.\w*|:\w*',
    \   },
    \ },
    \ 'sourceParams': {
    \   'buffer': {
    \     'requireSameFiletype': v:false,
    \     'limitBytes': 5000000,
    \     'fromAltBuf': v:true,
    \     'forceCollect': v:true,
    \   },
    \ },
    \ 'filterParams': {
    \   'matcher_fuzzy': {'splitMode': 'word'},
    \ },
    \ })
  call ddc#custom#patch_filetype(['python'], 'sources', ['nvim-lsp', 'neosnippet', 'file', 'around'])
  call ddc#custom#patch_filetype(['python'], 'sourceOptions', {
    \ 'nvim-lsp': {
    \   'forceCompletionPattern': '\.\w*|:\s\w*|import\s\w*|@\w*',
    \ },
    \ 'around': {
    \   'mark': 'A',
    \ },
    \ })
  call ddc#custom#patch_filetype(['python'], 'sourceParams', {
    \ 'around': {
    \   'maxSize': 500,
    \ },
    \ })
  call ddc#enable()
'''

[[plugins]]
repo = 'Shougo/ddc-ui-pum'
lazy = 1

[[plugins]]
repo = 'Shougo/ddc-around'
lazy = 1

[[plugins]]
repo = 'matsui54/ddc-buffer'
lazy = 1

[[plugins]]
repo = 'Shougo/ddc-matcher_head'
lazy = 1

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
lazy = 1

[[plugins]]
repo = 'LumaKernel/ddc-file'
lazy = 1

[[plugins]]
repo = 'tani/ddc-fuzzy'
lazy = 1

[[plugins]]
repo = 'Shougo/ddc-nvim-lsp'
lazy = 1

[[plugins]]
repo = 'Shougo/ddc-converter_remove_overlap'
lazy = 1
hook_source ='''
'''

[[plugins]]
repo = 'Shougo/pum.vim'
lazy = 1
hook_source = '''
  inoremap <C-n> <Cmd>call pum#map#insert_relative(+1)<CR>
  inoremap <C-p> <Cmd>call pum#map#insert_relative(-1)<CR>
  inoremap <C-y> <Cmd>call pum#map#confirm()<CR>

  call pum#set_option({
    \ 'border': 'single',
    \ })
'''

[[plugins]]
repo = 'matsui54/denops-popup-preview.vim'
lazy = 1
hook_source = '''
  call popup_preview#enable()
'''

[[plugins]]
repo = 'matsui54/denops-signature_help'
lazy = 1
on_event = ['InsertEnter']
hook_source = '''
  let g:signature_help_config = {
  \ 'border': v:true,
  \ 'maxWidth': 80,
  \ 'maxHeight': 30,
  \ 'style': "labelOnly",
  \ 'onTriggerChar': v:false,
  \ 'multiLabel': v:false,
  \ 'fallbackToBelow': v:true,
  \ }
  call signature_help#enable()
  inoremap <C-l> <Cmd>call signature_help#disable()<CR><Cmd>call SetSignatureHelpEnable()<CR>
  function! SetSignatureHelpEnable() abort
    autocmd myautocmd InsertLeave * ++once call signature_help#enable()
  endfunction
'''

[[plugins]]
repo = 'Shougo/neosnippet'
depends = 'neosnippet-snippets'
filetypes = 'neosnippet'
on_event = 'InsertEnter'
hook_source = '''
  let g:neosnippet#snippets_directory = expand('~/.config/nvim/snippets')
  imap <C-k> <C-y><Plug>(neosnippet_expand_or_jump)
  smap <C-k> <Plug>(neosnippet_expand_or_jump)
  xmap <C-l> <Plug>(neosnippet_expand_target)
  snoremap <C-l> <Esc>a
  snoremap <CR> <BS>i
'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = ['InsertEnter', 'CmdlineEnter']
hook_source = '''
  " lexima settings {{{
  let g:lexima_no_default_rules = 1
  let g:lexima_map_escape = ''
  let g:lexima_accept_pum_with_enter = 0
  call lexima#set_default_rules()

  nnoremap / <Cmd>set wrapscan<CR>/
  call lexima#add_rule({'char': '<CR>', 'input': '<CR><Cmd>set nowrapscan<CR>', 'mode': '/'})
  call lexima#add_rule({'char': '<Esc>', 'input': '<C-c><Cmd>set nowrapscan<CR>', 'mode': '/'})

  call lexima#add_rule({'at': '\S\s*\%#', 'char': '<Tab>', 'input': '', 'leave': 1})

  call lexima#add_rule({'at': '^\k\+\s*::\s*.*\%#', 'char': '<CR>', 'input': '<Esc>^"qyt<Space>o<C-r>q<Space>', 'filetype': ['haskell']})
  call lexima#add_rule({'at': '{-\%#}', 'char': '#', 'input': '# ', 'input_after': ' #-', 'filetype': ['haskell']})
  call lexima#add_rule({'at': '{\%#}', 'char': '<CR>', 'input': '<CR><Bslash> ', 'input_after': '<CR><Bslash> ', 'filetype': 'vim'})
  call lexima#add_rule({'at': '\\\s.*\%#$', 'char': '<CR>', 'input': '<CR><Bslash> ', 'filetype': 'vim'})

  call lexima#add_rule({'at': 'RenameMe\%#', 'char': '<Space>', 'input': '<Space><C-r>%', 'mode': ':'})
  call lexima#add_rule({'at': 'Git commit --amend \%#', 'char': 'c', 'input': '-C HEAD', 'mode': ':'})
  call lexima#add_rule({'at': 'Git commit --amend \%#', 'char': 'C', 'input': '-C HEAD', 'mode': ':'})
  call lexima#add_rule({'at': 'Git ca\%#', 'char': 'm', 'input': '<C-u>Gcommit --amend ', 'mode': ':'})

  call lexima#add_rule({'at': 'Ddu \%#', 'char': 'O', 'input': 'outline', 'mode': ':'})
  call lexima#add_rule({'at': '^\%#', 'char': '/', 'input': '<BS>:Ddu line<CR>', 'mode': '/'})
  call lexima#add_rule({'at': '^\%#', 'char': ':', 'input': '<BS>:Ddu command_history<CR>', 'mode': ':'})

  call lexima#add_rule({'at': '^\s*\%(Describe\|Context\|It\|Before\|After\)\s\+.*\%#', 'char': '<CR>', 'input_after': '<CR>End', 'filetype': 'vimspec'})

  call lexima#add_rule({'at': '\<\(\k\+\)\.\(_*\)self\%#', 'char': '<Space>', 'input': '<C-u>self.\2\1 = \1', 'filetype': 'python', 'with_submatch': 1})
  " inoremap <expr> <CR> pum#visible() ? "\<Cmd>call pum#map#confirm()\<CR>" : "\<C-r>=lexima#expand('<LT>CR>', 'i')\<CR>"
  inoremap <silent> <Esc> <C-r>=lexima#insmode#escape()<CR><C-r>=FixedInsertLeave()<CR>:call ImActivateFunc(0)<CR>
  " }}}
'''

# TextObj
[[plugins]]
repo = 'kana/vim-textobj-user'

[[plugins]]
repo = 'kana/vim-textobj-indent'
depends = 'vim-textobj-user'

[[plugins]]
repo = 'kana/vim-textobj-entire'
depends = 'vim-textobj-user'
on_map = {ox = ['ie', 'ae']}

[[plugins]]
repo = 'thinca/vim-textobj-between'
depends = 'vim-textobj-user'
on_map = {ox = '<Plug>'}
hook_add = '''
  let g:textobj_between_no_default_key_mappings = 1
  omap i/ <Plug>(textobj-between-i)
  xmap i/ <Plug>(textobj-between-i)
  omap a/ <Plug>(textobj-between-a)
  xmap a/ <Plug>(textobj-between-a)
'''

[[plugins]]
repo = 'kana/vim-textobj-line'
depends = 'vim-textobj-user'

[[plugins]]
repo = 'gilligan/textobj-lastpaste'
depends = 'vim-textobj-user'
hook_add = '''
  let g:textobj_lastpaste_no_default_key_mappings = 1
  omap iP <Plug>(textobj-lastpaste-i)
  xmap iP <Plug>(textobj-lastpaste-i)
'''

[[plugins]]
repo = 'thinca/vim-textobj-comment'
depends = 'vim-textobj-user'
on_map = {ox = ['ic', 'ac']}

[[plugins]]
repo = 'machakann/vim-textobj-functioncall'
depends = ['vim-textobj-user']
on_map = {ox = ['iF', 'aF', 'ia', 'aa', 'ig', 'ag']}
hook_source = '''
  let g:textobj_functioncall_no_default_key_mappings = 1
  xmap iF <Plug>(textobj-functioncall-i)
  omap iF <Plug>(textobj-functioncall-i)
  xmap aF <Plug>(textobj-functioncall-a)
  omap aF <Plug>(textobj-functioncall-a)

  let g:my_textobj_functioncall_bracket_patterns = [
  \ {
  \   'header' : '\<\%(\h\k*\.\)*\h\k*',
  \   'bra': '\[',
  \   'ket': '\]',
  \   'footer' : '',
  \ }]
  onoremap <silent> ig :<C-u>call textobj#functioncall#i('o', g:my_textobj_functioncall_bracket_patterns)<CR>
  xnoremap <silent> ig :<C-u>call textobj#functioncall#i('x', g:my_textobj_functioncall_bracket_patterns)<CR>
  onoremap <silent> ag :<C-u>call textobj#functioncall#a('o', g:my_textobj_functioncall_bracket_patterns)<CR>
  xnoremap <silent> ag :<C-u>call textobj#functioncall#a('x', g:my_textobj_functioncall_bracket_patterns)<CR>

  let g:my_textobj_functioncall_angle_bracket_patterns = [
  \ {
  \   'header' : '\<\%(\h\k*\.\)*\h\k*',
  \   'bra': '<',
  \   'ket': '>',
  \   'footer' : '',
  \ }]

  onoremap <silent> ia :<C-u>call textobj#functioncall#i('o', g:my_textobj_functioncall_angle_bracket_patterns)<CR>
  xnoremap <silent> ia :<C-u>call textobj#functioncall#i('x', g:my_textobj_functioncall_angle_bracket_patterns)<CR>
  onoremap <silent> aa :<C-u>call textobj#functioncall#a('o', g:my_textobj_functioncall_angle_bracket_patterns)<CR>
  xnoremap <silent> aa :<C-u>call textobj#functioncall#a('x', g:my_textobj_functioncall_angle_bracket_patterns)<CR>
'''

# Operator
[[plugins]]
repo = 'machakann/vim-sandwich'
depends = ['vim-textobj-functioncall']
hook_add = '''
  let g:sandwich_no_default_key_mappings = 1
  let g:operator_sandwich_no_default_key_mappings = 1
  let g:textobj_sandwich_no_default_key_mappings = 1
  nmap ys <Plug>(sandwich-add)
  nmap ds <Plug>(sandwich-delete)
  nmap cs <Plug>(sandwich-replace)
  xmap S <Plug>(sandwich-add)
  let g:sandwich#recipes = deepcopy(g:sandwich#default_recipes)
  let g:sandwich#recipes += [
  \ {
  \   'buns': ['MySandwichFuncName("[")', '"]"'],
  \   'expr': 1,
  \   'cursor': 'inner_tail',
  \   'kind': ['add', 'replace'],
  \   'action': ['add'],
  \   'input': ['g']
  \ },
  \ {
  \   'buns': ['MySandwichFuncName("<")', '">"'],
  \   'expr': 1,
  \   'cursor': 'inner_tail',
  \   'kind': ['add', 'replace'],
  \   'action': ['add'],
  \   'input': ['a']
  \ },
  \ {
  \   'external': ['i[', "ig"],
  \   'noremap': 0,
  \   'kind': ['delete', 'replace', 'query'],
  \   'input': ['g']
  \ },
  \ {
  \   'external': ['i<', "ia"],
  \   'noremap': 0,
  \   'kind': ['delete', 'replace', 'query'],
  \   'input': ['a']
  \ },
  \ ]

  function! MySandwichFuncName(bra) abort
    let funcname = input('name: ', '')
    if funcname ==# ''
      throw 'OperatorSandwichCancel'
    endif
    return funcname .. a:bra
  endfunction

  let g:sandwich#magicchar#f#patterns = [
  \   {
  \     'header' : '\<\%(\h\k*\.\)*\h\k*',
  \     'bra'    : '(',
  \     'ket'    : ')',
  \     'footer' : '',
  \   },
  \ ]
'''

[[plugins]]
repo = 'tpope/vim-commentary'
on_map = {nx = ['gc', 'gC']}

[[plugins]]
repo = 'kana/vim-operator-user'

[[plugins]]
repo = 'kana/vim-operator-replace'
depends = 'vim-operator-user'
on_map = {nox = '<Plug>'}
hook_add = '''
  map _ <Plug>(operator-replace)
  sunmap _
'''

[[plugins]]
repo = 'tyru/operator-camelize.vim'
depends = 'kana/vim-operator-user'
on_map = {nox = '<Plug>'}
hook_add = '''
  map - <Plug>(operator-camelize-toggle)
  sunmap -
'''

[[plugins]]
repo = 'tommcdo/vim-exchange'
on_map = {nox = ['<Plug>(Exchange)', '<Plug>(ExchangeLine)', '<Plug>(ExchangeClear)']}
on_cmd = 'XchangeClear'
hook_add = '''
  let g:exchange_no_mappings = 1
  nmap cx <Plug>(Exchange)
  nmap cxx <Plug>(ExchangeLine)
  xmap X <Plug>(Exchange)
  autocmd myautocmd TextChanged * XchangeClear
'''

# Editing
[[plugins]]
repo = 'h1mesuke/vim-alignta'
on_cmd = ['Alignta', 'Align']

[[plugins]]
repo = 'thinca/vim-template'
hook_add = '''
  autocmd User plugin-template-loaded call MyTemplateLoaded()

  function! MyTemplateLoaded()
    if search('<CURSOR>')
      execute 'normal! "_da>'
    endif
  endfunction
'''


[[plugins]]
repo = 'thinca/vim-qfreplace'
on_cmd = 'Qfreplace'
hook_add = '''
  function! QfreplaceSettings() abort
    nnoremap <buffer> r :<C-u>Qfreplace<CR>
  endfunction
  autocmd myautocmd FileType qf call QfreplaceSettings()
'''

# File
[[plugins]]
repo = 'scrooloose/nerdtree'
on_cmd = ['NERDTreeToggle', 'NERDTreeFind']
hook_add = '''
  nnoremap <silent> <C-p> :<C-u>NERDTreeToggle<CR>
  nnoremap <silent> <C-@> :<C-u>NERDTreeFind<CR>
  nnoremap <silent> \<C-p> :<C-u>NERDTreeFind<CR>
  let g:NERDTreeIgnore = ['\~$', '\.swp', '^\.$', '^\.\.$']
  let g:NERDTreeHijackNetrw = 0
  let g:NERDTreeQuitOnOpen = 1
  let g:NERDTreeWinSize = 36
  let g:NERDTreeMinimalUI = 1
  let g:NERDTreeChDirMode = 1
  let g:NERDTreeMapCWD = "cD"
  if !g:is_unicode
    let g:NERDTreeDirArrows = 0
  endif
'''

[[plugins]]
repo = 'lambdalisue/suda.vim'
hook_add = '''
  command! SudoWrite w suda://%
'''


# Motion
[[plugins]]
repo = 'bkad/CamelCaseMotion'
hook_add = '''
  map + [CamelCaseMotion]
  map <silent> [CamelCaseMotion]w <Plug>CamelCaseMotion_w
  map <silent> [CamelCaseMotion]b <Plug>CamelCaseMotion_b
  map <silent> [CamelCaseMotion]e <Plug>CamelCaseMotion_e
  sunmap +
  sunmap [CamelCaseMotion]w
  sunmap [CamelCaseMotion]b
  sunmap [CamelCaseMotion]e
'''

[[plugins]]
repo = 'Lokaltog/vim-easymotion'
on_map = {nox = '<CR>'}
hook_source = '''
nmap <CR> [EasyMotion]
omap <CR> [EasyMotion]
xmap <CR> [EasyMotion]
let g:EasyMotion_leader_key = '[EasyMotion]'
'''

[[plugins]]
repo = 'kana/vim-smartword'
on_map = '<Plug>'
hook_add = '''
nmap w <Plug>(smartword-w)
nmap b <Plug>(smartword-b)
nmap e <Plug>(smartword-e)
nmap ge <Plug>(smartword-ge)
xmap w <Plug>(smartword-w)
xmap b <Plug>(smartword-b)
xmap e <Plug>(smartword-e)
xmap ge <Plug>(smartword-ge)
'''

[[plugins]]
repo = 'deton/jasentence.vim'
on_map = {nox = ['(', ')'], ox = ['as', 'is']}

[[plugins]]
repo = 'thinca/vim-visualstar'
on_map = '<Plug>'
hook_add = '''
  let g:visualstar_no_default_key_mappings = 1
  xmap * <Plug>(visualstar-*)
  xmap # <Plug>(visualstar-#)
  xmap g* <Plug>(visualstar-g*)
  xmap g# <Plug>(visualstar-g#)
'''

[[plugins]]
repo = 'deris/columnjump'
on_map = '<Plug>'
hook_add = '''
  let g:columnjump_ignore_wrapped_lines = 1
  nmap <C-k> <Plug>(columnjump-backward)
  xmap <C-k> <Plug>(columnjump-backward)
  nmap <C-j> <Plug>(columnjump-forward)
  xmap <C-j> <Plug>(columnjump-forward)
'''

[[plugins]]
repo = 'kana/vim-gf-user'
lazy = 1

[[plugins]]
repo = 'sgur/vim-gf-autoload'
depends = 'vim-gf-user'
on_ft = 'vim'

# Appearance
[[plugins]]
repo = 'nathanaelkane/vim-indent-guides'
if = '!has("nvim")'
hook_add = '''
  let g:indent_guides_enable_on_vim_startup = 1
  let g:indent_guides_auto_colors = 0
'''

[[plugins]]
repo = 'lukas-reineke/indent-blankline.nvim'
if = 'has("nvim")'
hook_post_source = '''
lua <<EOF
  require('indent_blankline').setup {
    char = "",
    char_highlight_list = {
      'IndentGuidesOdd',
      'IndentGuidesEven',
    },
    space_char_highlight_list = {
      'IndentGuidesOdd',
      'IndentGuidesEven',
    },
    show_trailing_blankline_indent = false,
    show_current_context = true,
    indent_blankline_show_current_context_start = true,
    filetype_exclude = {'help', 'ddu-ff'},
    context_pattern_highlight = {
      class = 'NonText',
      ['^func'] = 'NonText',
      method = 'NonText',
      ['^if'] = 'NonText',
      ['while'] = 'NonText',
      ['for'] = 'NonText',
      ['with'] = 'NonText',
      ['try'] = 'NonText',
      ['except'] = 'NonText',
      arguments = 'NonText',
      argument_list = 'NonText',
      object = 'NonText',
      dictionary = 'NonText',
      element = 'NonText',
      table = 'NonText',
      tuple = 'NonText',
    },
  }
EOF
'''


[[plugins]]
repo = 'thinca/vim-fontzoom'
on_if = 'g:is_gui'
on_map = {n = '<Plug>'}
hook_add = '''
  let g:fontzoom_no_default_key_mappings = 1
  nmap <C-ScrollWheelUp>   <Plug>(fontzoom-larger)
  nmap <C-ScrollWheelDown> <Plug>(fontzoom-smaller)
'''

[[plugins]]
repo = 'cohama/vim-insert-linenr'
on_event = 'InsertEnter'

# Git
[[plugins]]
repo = 'tpope/vim-fugitive'
hook_add = '''
  nnoremap [Git] <Nop>
  nmap <Space> [Git]
  nnoremap [Git]<Space> :<C-u>Git<Space>
  nnoremap [Git]s :<C-u>Git<CR>
  nnoremap [Git]d :<C-u>Gvdiffsplit<CR>
  nnoremap [Git]a :<C-u>Gwrite<CR>
  nnoremap [Git]A :<C-u>Git add -A<CR>
  nnoremap [Git]c :<C-u>Git commit -v<CR>
  nnoremap [Git]C :<C-u>Git commit --amend<Space>
  nnoremap [Git]p :<C-u>Git push<CR>
  nnoremap [Git]f :<C-u>Git fetch<CR>
  nnoremap [Git]F :<C-u>Git pull --rebase<CR>
  nnoremap [Git]b :<C-u>Git blame<CR>

  autocmd myautocmd FileType fugitive call MyFugitiveSettings()
  function MyFugitiveSettings() abort
    nmap <buffer> D dd
    nnoremap <buffer> q :<C-u>q<CR>
  endfunction
'''

[[plugins]]
repo = 'cohama/agit.vim'
on_cmd = ['Agit', 'AgitFile']
hook_add = '''
  autocmd myautocmd FileType agit call s:my_agit_settings()
  function! s:my_agit_settings()
    nmap <buffer> Rv <Plug>(agit-git-revert)
    nmap <buffer> cB :<C-u>AgitGit branch -f \%# <hash><CR>
    nnoremap <buffer> [Git]<Space> :<C-u>AgitGit<Space>
  endfunction
  nnoremap [Git]k :<C-u>Agit<CR>
  nnoremap [Git]K :<C-u>AgitFile<CR>
'''

[[plugins]]
repo = 'airblade/vim-gitgutter'
on_cmd = ['GitGutterToggle', 'GitGutterNextHunk', 'GitGutterNextHunk']
hook_add = '''
  let g:gitgutter_enabled = 0
  nmap <silent> ]h :<C-u>execute v:count1 . "GitGutterNextHunk"<CR>
  nmap <silent> [h :<C-u>execute v:count1 . "GitGutterPrevHunk"<CR>
  nnoremap [Git]g :<C-u>GitGutterToggle<CR>
'''

# Language Support
[[plugins]]
repo = 'itchyny/vim-haskell-indent'
on_ft = 'haskell'

[[plugins]]
repo = 'racer-rust/vim-racer'
on_ft = 'rust'
hook_add = '''
  let g:racer_experimental_completer = 1
'''

[[plugins]]
repo = 'Vimjas/vim-python-pep8-indent'
on_ft = 'python'

# Execution
[[plugins]]
repo = 'thinca/vim-quickrun'
on_map = {n = '\r'}
on_cmd = 'QuickRun'
depends = 'quickrun-job-runner.nvim'
hook_add = '''
  autocmd myautocmd BufWinEnter,BufNewFile test/*.vim,test/*.vimspec let b:quickrun_config = {'type' : 'themis'}
  autocmd myautocmd BufWinEnter QuickRunOut setlocal winfixheight
  autocmd myautocmd BufWinLeave QuickRunOut call quickrun#sweep_sessions()
  command! QuickRunCancel call quickrun#sweep_sessions()
'''
hook_source = '''
  " quickrun settings {{{
  let g:quickrun_config = {}
  let g:quickrun_config['_'] = {
  \ 'hook/close_buffer/enable_failure'   : 1,
  \ 'hook/close_buffer/enable_empty_data': 1,
  \ 'outputter'                          : 'multi:buffer:quickfix',
  \ 'outputter/buffer/split'             : 'botright 8',
  \ 'outputter/buffer/name'              : 'QuickRunOut',
  \ 'outputter/buffer/close_on_empty'    : 1,
  \ 'outputter/quickfix/open_cmd'        : '',
  \ 'runner'                             : 'nvim_job',
  \ 'hook/echo/enable'                   : 1,
  \ 'hook/echo/output_success'           : 'success',
  \ 'hook/echo/output_failure'           : 'failure',
  \ }
  let g:quickrun_config['watchdogs_checker/_'] = {
  \ 'hook/close_unite_quickfix/enable_exit'    : 1,
  \ 'hook/back_window/enable_exit'             : 0,
  \ 'hook/quickfix_status_enable/enable_exit'  : 1,
  \ 'outputter/quickfix/open_cmd'              : '',
  \ 'hook/hier_update/enable_exit'             : 1,
  \ 'hook/back_window/priority_exit'           : 1,
  \ 'hook/quickfix_status_enable/priority_exit': 2,
  \ 'hook/hier_update/priority_exit'           : 3,
  \ 'hook/nuko/enable'  : 1,
  \ }
  let g:quickrun_config['ocaml/watchdogs_checker'] = {
  \ 'type': 'watchdogs_checker/ocamlc'
  \ }
  let g:quickrun_config['watchdogs_checker/make'] = {
  \ 'command': 'make',
  \ 'exec': '%c %o'
  \ }
  let g:quickrun_config['watchdogs_checker/ocamlc'] = {
  \ 'command': 'ocamlc',
  \ 'exec'   : '%c -i %o - %s:p'
  \ }
  let g:quickrun_config['watchdogs_checker/ocamlc_annot'] = {
  \ 'command': 'ocamlc',
  \ 'exec'   : '%c -annot -bin-annot -c %o - %s:p'
  \ }
  let g:quickrun_config['watchdogs_checker/hxml'] = {
  \ 'command': 'haxe',
  \ 'exec'   : '%c build.hxml'
  \ }
  let g:quickrun_config['haxe/watchdogs_checker'] = {
  \ 'type': 'watchdogs_checker/hxml'
  \ }
  let g:quickrun_config['ruby.rspec'] = {
  \ 'command': 'bundle',
  \ 'exec': '%c exec rspec -f d %s'
  \ }
  let g:quickrun_config['ghc_make'] = {
  \ 'command'                       : 'ghc',
  \ 'exec'                          : '%c %s',
  \ 'outputter'                     : 'quickfix',
  \ 'outputter/quickfix'            : 1,
  \ 'outputter/quickfix/open_cmd'   : 'cwindow',
  \ 'hook/back_window/enable_exit'  : 1,
  \ 'hook/back_window/priority_exit': 1
  \ }
  let g:quickrun_config['ghc_doctest'] = {
  \ 'command': 'doctest',
  \ 'exec': '%c %s'
  \ }
  let g:quickrun_config['stack_build'] = {
  \ 'command'                       : 'stack',
  \ 'exec'                          : '%c build',
  \ 'outputter'                     : 'quickfix',
  \ 'outputter/quickfix'            : 1,
  \ 'outputter/quickfix/open_cmd'   : 'botright cwindow',
  \ 'hook/back_window/enable_exit'  : 1,
  \ 'hook/back_window/priority_exit': 1,
  \ 'hook/nuko/enable'              : 1,
  \ }
  let g:quickrun_config['stack_exec'] = {
  \ 'command'                       : 'stack',
  \ 'exec'                          : '%c exec %a',
  \ 'outputter'                     : 'buffer',
  \ }
  let g:quickrun_config['haskell'] = {'type': 'haskell/stack_runghc'}
  let g:quickrun_config['haskell/stack_runghc'] = {
  \ 'command'           : 'stack',
  \ 'exec'              : '%c runghc %s %a',
  \ 'tempfile'          : '%{tempname()}.hs',
  \ 'hook/eval/template': 'main = print \$ %s',
  \ }
  let g:quickrun_config['haskell/watchdogs_checker'] = {'type': 'watchdogs_checker/stack_ghcmod'}
  let g:quickrun_config['watchdogs_checker/stack_ghcmod'] = {
  \ 'command'           : 'stack',
  \ 'exec'              : '%c exec ghc-mod check %s:p | sed "s/\x0/\n/g"',
  \ 'errorformat'       : '%f:%l:%c:%trror: %m,%f:%l:%c:%tarning: %m,%f:%l:%c:parse %trror %m,%f:%l:%c: %trror: %m,%f:%l:%c: %tarning: %m,%f:%l:%c:%m,%E%f:%l:%c:,%Z%m',
  \ 'tempfile'          : 'TemporaryWatchDogSourceFile.hs'
  \ }
  let g:quickrun_config['rust/watchdogs_checker'] = {'type': 'watchdogs_checker/myrustc'}
  let g:quickrun_config['watchdogs_checker/myrustc'] = {
  \ 'command'           : 'rustc',
  \ 'exec'              : '%c -Z no-trans %s:p',
  \ }
  let g:quickrun_config['watchdogs_checker/cargo_check'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c check',
  \ }
  let g:quickrun_config['cargo_run'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c run',
  \ }
  let g:quickrun_config['cargo_build'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c build',
  \ }
  let g:quickrun_config['cargo_test'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c test',
  \ 'outputter/buffer/split'             : 'botright vertical 80',
  \ }
  let g:quickrun_config['watchdogs_checker/cargo_clippy'] = {
  \ 'command'           : 'cargo',
  \ 'exec'              : '%c clippy',
  \ }
  let g:quickrun_config['themis'] = {
  \ 'command': 'themis',
  \ 'exec': '%c --reporter dot %s'
  \ }
  " }}}
'''

[[plugins]]
repo = 'tamy0612/quickrun-job-runner.nvim'
lazy = 1

[[plugins]]
repo = 'kana/vim-submode'
on_map = {n = ['<C-W>+', '<C-W>-', '<C-W>>', '<C-W><']}
hook_add = '''
  let g:submode_keep_leaving_key = 1
  let g:submode_timeout = 0
'''
hook_source = '''
  call submode#enter_with('winsize', 'n', '', '<C-W>>', '<C-W>>')
  call submode#enter_with('winsize', 'n', '', '<C-W><', '<C-W><')
  call submode#enter_with('winsize', 'n', '', '<C-W>+', '<C-W>+')
  call submode#enter_with('winsize', 'n', '', '<C-W>-', '<C-W>-')
  call submode#map('winsize', 'n', '', '>', '<C-W>>')
  call submode#map('winsize', 'n', '', '<', '<C-W><')
  call submode#map('winsize', 'n', '', '+', '<C-W>+')
  call submode#map('winsize', 'n', '', '-', '<C-W>-')
'''

[[plugins]]
repo = 'tyru/open-browser.vim'
on_map = '<Plug>(openbrowser-'
hook_add = '''
  let g:netrw_nogx = 1
  nmap gx <Plug>(openbrowser-smart-search)
  xmap gx <Plug>(openbrowser-smart-search)
'''

[[plugins]]
repo = 'thinca/vim-themis'

[[plugins]]
repo = 'previm/previm'
on_cmd = 'PrevimOpen'
depends = ['open-browser.vim']

# Miscellaneous
[[plugins]]
repo = 'mattn/webapi-vim'
lazy = 1

[[plugins]]
repo = 'mattn/gist-vim'
depends = 'webapi-vim'
on_cmd = 'Gist'

[[plugins]]
repo = 'thinca/vim-localrc'

[[plugins]]
repo = 'thinca/vim-prettyprint'
on_cmd = ['PP', 'PrettyPrint']

[[plugins]]
repo = 'subnut/nvim-ghost.nvim'
hook_post_update = '''
  call nvim_ghost#installer#install()
'''
hook_add = '''
  autocmd myautocmd User *github.com set filetype=markdown
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
hook_post_update = '''
  TSUpdate
'''
on_event = 'VimEnter'
hook_source = '''
lua <<EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = "all",
  ignore_install = {},
  highlight = {
    enable = true,
    disable = {"vim", "help", "toml"},
    additional_vim_regex_highlighting = false
  },
  indent = {
    enable = true,
    disable = {"python"}
  }
}
EOF

set foldexpr=nvim_treesitter#foldexpr()
'''

[[plugins]]
repo = 'tweekmonster/helpful.vim'
on_cmd = ['HelpfulVersion']
